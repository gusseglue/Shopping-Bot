// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String?  @map("password_hash")
  name         String?
  role         Role     @default(USER)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  devices        Device[]
  subscription   Subscription?
  watchers       Watcher[]
  alerts         Alert[]
  webhookConfigs WebhookConfig[]
  auditLogs      AuditLog[]
  refreshTokens  RefreshToken[]
  authenticators Authenticator[]

  @@map("users")
}

// WebAuthn Authenticator (Passkey) model
model Authenticator {
  id                   String   @id @default(uuid())
  userId               String   @map("user_id")
  credentialId         String   @unique @map("credential_id")
  credentialPublicKey  Bytes    @map("credential_public_key")
  counter              BigInt
  credentialDeviceType String   @map("credential_device_type")
  credentialBackedUp   Boolean  @map("credential_backed_up")
  transports           String[] // Array of transport types
  name                 String?  // User-friendly name for the passkey
  createdAt            DateTime @default(now()) @map("created_at")
  lastUsedAt           DateTime? @map("last_used_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("authenticators")
}

enum Role {
  USER
  ADMIN
}

// Device model for device registration
model Device {
  id          String         @id @default(uuid())
  userId      String         @map("user_id")
  name        String
  fingerprint String
  platform    DevicePlatform
  lastSeenAt  DateTime       @default(now()) @map("last_seen_at")
  createdAt   DateTime       @default(now()) @map("created_at")
  revokedAt   DateTime?      @map("revoked_at")

  // Relations
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshTokens RefreshToken[]

  @@unique([userId, fingerprint])
  @@map("devices")
}

enum DevicePlatform {
  WINDOWS
  MACOS
  LINUX
  WEB
}

// Refresh token model
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  deviceId  String?  @map("device_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  revokedAt DateTime? @map("revoked_at")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  device Device? @relation(fields: [deviceId], references: [id], onDelete: SetNull)

  @@map("refresh_tokens")
}

// Subscription model
model Subscription {
  id                    String             @id @default(uuid())
  userId                String             @unique @map("user_id")
  stripeCustomerId      String             @map("stripe_customer_id")
  stripeSubscriptionId  String?            @map("stripe_subscription_id")
  plan                  Plan               @default(FREE)
  status                SubscriptionStatus @default(ACTIVE)
  currentPeriodStart    DateTime?          @map("current_period_start")
  currentPeriodEnd      DateTime?          @map("current_period_end")
  cancelAtPeriodEnd     Boolean            @default(false) @map("cancel_at_period_end")
  createdAt             DateTime           @default(now()) @map("created_at")
  updatedAt             DateTime           @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

enum Plan {
  FREE
  BASIC
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  PAST_DUE
  PAUSED
  TRIALING
  UNPAID
}

// Watcher model
model Watcher {
  id           String        @id @default(uuid())
  userId       String        @map("user_id")
  url          String
  name         String
  domain       String
  rules        Json
  interval     Int           // in seconds
  status       WatcherStatus @default(ACTIVE)
  lastCheckAt  DateTime?     @map("last_check_at")
  lastAlertAt  DateTime?     @map("last_alert_at")
  lastResult   Json?         @map("last_result")
  errorCount   Int           @default(0) @map("error_count")
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  alerts Alert[]

  @@index([userId])
  @@index([domain])
  @@index([status])
  @@map("watchers")
}

enum WatcherStatus {
  ACTIVE
  PAUSED
  ERROR
  DISABLED
}

// Alert model
model Alert {
  id        String    @id @default(uuid())
  watcherId String    @map("watcher_id")
  userId    String    @map("user_id")
  type      AlertType
  data      Json
  readAt    DateTime? @map("read_at")
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  watcher Watcher @relation(fields: [watcherId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([watcherId])
  @@index([createdAt])
  @@map("alerts")
}

enum AlertType {
  PRICE_CHANGE
  BACK_IN_STOCK
  SIZE_AVAILABLE
  ERROR
}

// Webhook configuration model
model WebhookConfig {
  id           String      @id @default(uuid())
  userId       String      @map("user_id")
  type         WebhookType
  url          String      // Encrypted
  enabled      Boolean     @default(true)
  lastTestedAt DateTime?   @map("last_tested_at")
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@map("webhook_configs")
}

enum WebhookType {
  DISCORD
  SLACK
  CUSTOM
}

// Audit log model
model AuditLog {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  action    String
  metadata  Json?
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// WebAuthn Challenge storage model
model WebAuthnChallenge {
  id        String   @id @default(uuid())
  challenge String   @unique
  userId    String?  @map("user_id") // Null for registration of new users
  email     String?  // Email for new user registration
  userName  String?  @map("user_name") // Name for new user registration
  type      String   // 'registration' or 'authentication'
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([challenge])
  @@index([expiresAt])
  @@map("webauthn_challenges")
}
